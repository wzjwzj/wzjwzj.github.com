---
layout: post
title: "kiwi_info"
category: "uncategorized"
tags: info
 
toc:
widget:
mathjax: true
prettify: true
htmlhead: <style>table,th,td,tr{border:none; background-color:white ; text-align:left;width:auto;padding-left:20px;}</style>
---
{% include JB/setup %}
 
Kiwi info:

GIT | repository | branch
--- | ---------- | :----
    | kiwi       | master<br/>kiwi_asa<br/><strong style="padding-left:30px">kiwi_asa_dev</strong> <br/><span style="padding-left:60px">kiwi_asa_bug</span>

<!--end_excerpt-->

[TOC]

## 测试模拟退火

```python
$cat test_sa1.sh
../minimizer <<EOF                             #   !  dip   .and.  strike  
  make clean                                   #
  set_effective_dt  1.0                        #  params ctrl discretize size
  set_source_location -F1 -L30.52/83.75        #  src coordinate
  set_source_params_vs eikonal_modify -F1 -M3.35E+18/180/45/-5 -L8000.0/5000.0r
  set_inversion_method slipgen -K0.8  #-G # -P0.5  # -G -S0.8  #  random generate slip-distribution 
  generate_static_data -Vn -F5.0/5.0/5.0       #  random generate obs coordinate
  output_static_data unfilter syn              #  calculate syn data
  plot source                                  #  
  sh plot_gmt.sh                               #  plot the figure
  cp plot_gmt.sh plot_gmt1.sh                  #
  cp a.ps a1.ps                                #   
  #---------------------------- 
  # quit 				       #
  #-------inverse modelling----                #
  set_source_params_vs eikonal_modify -F1 -M3.35E+18/180/40/0 -L8000.0/5000.0r
  set_inversion_method sa1  -C1/1/0/1  -N100/1000/0 -R0.5/0 -S0.1 -T100/100
                         #  -Cv1/v2/v3/[/v4[v5]]   ! v1:iselect v2:ioptimize. v3: imisfit v4:ireduction: v5:istartmodel
  #quit
  r_st1 unfilter*.h5  # as filtered data      #  read data
  get_misfits_static                          #  get_result.
  output_static_data filter syn               #  output_result
  plot source                                 #  
  sh plot_gmt.sh                                  #  plot the figure
  mv plot_gmt.sh plot_gmt2.sh                         #  
  mv a.ps a2.ps                               #  
  quit                                        #  release memory
EOF
  
#h5dump -d /t_static_single_dataset/disp  unfilter*.h5 > tmp.info
#h5dump -d /t_static_single_dataset/disp  filter*.h5   >> tmp.info

```


## set_source_location
Set source spacial and Temporal ref point:  lat, lon, time.

**syntax:**  
>`set_source_location -F<n> -L<lat>/<lon> [-T<time>]`

**Parameters:**  
> lat: latitude in degree.  
> lon: longitude in degree.  
> time: optional default: 0. 

**info**     
> `set_source_location( options_vs,ok )` in `minimizer_engine.f90`      
> call  `psm_set_origin_and_time( psm,orign,ref_time)` in `parameterized_source.f90`   
> type(t_geo_coords),intent(in) :: origin  # ** coord in radius **    
>> `call psm_set_default_constrains( psm )`     
>>  psm -> origin -> thickness:    
>>  **default constrains: top: 1.5km, bottom:  thickness.**     

## set_source_params_vs
set source parameters 

**syntax:**   
>`set_source_params_vs <clean|bilateral|eikonal|...>  options`   

**examples**    
>`set_source_params_vs eikonal_modify -F1 -M3.35E+18/180/45/-5 -L8000.0/5000.0r`   

**info**   
> call `parse_psm_params` => real:dimension(:) :: sourceparams  
> call `psm_set`  =>  
>> call `psm_set_eikonal` 
>> ***parameter of eikonal_modify:***    
`-F :`   
`[-R<t0>/<x>/<y>/<z>] :`   
`[-M<m>/<strike0>[:<strike1>]/<dip0>[:<dip1>]/<rake>] :`   
`[-B<bord_shift_x/bord_shift_y>] :`   
`[-L<bord-semi-length>/[<bord-semi-width>][e|r]] :` default:     
`[-H<nukl-shift-x/nukl-shift-y>[c|r]] :` default:    
`[-V<relative-rupture-velocity>[/<Vs>]] :`  discretize 中用到   
`[-T<rise_time>] :`   
`[-D<nx_cutoff/ny_cutoff>] : [2~HUGE(1)) : HUGE(1):` 只用来限制cgrid  
`[-K] :`   

`subroutine psm_set_eikonal_modify( psm, params, normalized, only_moment_changed)`

`params ==> new_params ==> psm_params_cache_eikonal_modfify`
`params ==> new_params ==> psm%params`

## psm_to_discretize_eikonal_modify ##
discrete source

**info**
>`subroutine psm_to_discretize_eikonal_modify( psm, shortest_doi,ok )`

***shortest_doi***     
>shortest_doi
>`set_effective_dt` => `effective_dt` (全局变量)    
>`update_source_discrete`    
> => `call psm_to_discretize_wrap( list_node%psm, effective_dt, ok )` 
>   
>   
> `call psm_to_grid_size( psm, shortest_doi , ok )`   ： 计算 &Delta; Nx,Ny
> `call psm_make_eikonal_grid( psm, psm%egrid, ok )`  :  分配空间，算rupture front
> `call psm_downsample_grid(  psm, psm%egrid, psm%cgrid )` ： 下采样


psm_to_grid_size:
<pre class="linenums:4">
delta=min(100.*max(shortest_doi,0.5)/2.,4000.)   ! delta_max=4km     ; delta_min= 100*0.25=25m
nxf=floor(2.0*bord_semi_x/delta)                 ! 2.0*2265/50=90    ; 
nyf=floor(2.0*bord_semi_y/delta)                 ! 2.0*3150/50=126
if(nxf.le.1) nxf=2 ; if(bord_semi_x.eq.0) nxf=1  ! line source
if(nyf.le.1) nyf=2 ; if(bord_semi_y.eq.0) nyf=1  ! line source
!print *,'--> nxf,nyf' ,nxf,nyf  ! 90,126
delta_x = 2.0*bord_semi_x/nxf  ! 
delta_y = 2.0*bord_semi_y/nyf  !
</pre>
<font size="3" color="red" style="font-weight:bold;">  如果100计算则 delta 大概 = shortest_doi*50m, 目前采用的是比较笨的方法，egrid采用100m/s，cgrid采用rup_min_vs，反演格点采用cgrid，画图采用采用egrid，更为合理的是采用插值画图,避免使用egrid,但是因为边界的限制是随机的,任意的,计算边界采用了较小格点。先用bord_seim_x,bord_seim_y,effective_dt，100m/s 决定delta，然后考虑边界限制，获取几何边界，然后再一次计算delta.同时，算走时，用小格点精确点，还是需要用egrid</font>

**期望更新：画图是采用基函数插值渲染, 第三步 psm_downsample_grid. 为egrid=>cgrid，应该弄个双向的，增加个插值cgrid=>egrid，ie: psm_resample_grid(decimate|stretch) **. 


